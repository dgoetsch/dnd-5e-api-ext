///*
// * This Kotlin source file was generated by the Gradle 'init' task.
// */

import dandd.character.automation.*
import dandd.character.automation.models.*
import io.ktor.client.HttpClient
import io.ktor.client.engine.js.Js
import io.ktor.client.request.get
import io.ktor.client.request.header
import io.ktor.client.statement.HttpResponse
import io.ktor.client.statement.readText
import io.ktor.http.HttpStatusCode
import kotlinx.coroutines.MainScope
import kotlinx.coroutines.launch
import parse.*
import react.Child
import react.dom.*
import kotlin.browser.document
import kotlin.js.Json

sealed class ApiClientError
data class UnsuccessfulRequest(val statusCode: HttpStatusCode, val body: String): ApiClientError()
data class RequestReadFailed(val e: Exception): ApiClientError()
data class ClientParseError(val error: ParseError): ApiClientError()
class ApiCient(val client: HttpClient) {
    suspend fun <T> getResource(type: String, name: String, parse: (String) -> Either<ApiClientError, T>): Either<ApiClientError, T> {
        val response = client
                .get<HttpResponse>("http://localhost:8099/api/$type/$name") {}
        val readBody = try {
            Right(response.readText())
        } catch (e: Exception) {
            Left(RequestReadFailed(e))
        }
        return readBody.bindRight { body ->
             when (response.status.value) {
                in 200..299 -> parse(body)
                else -> Left(UnsuccessfulRequest(response.status, body))
            }
        }
    }
}
fun Parser<Any?>.readNameUrl() =
    NameUrl(
            readStringField("name"),
            readStringField("url")
    )
fun Parser<Json?>.readUrlClass() =
        UrlClass(
                readStringField("url"),
                readStringField("class")
        )
val parseThing = { responseBody: String ->
    Either.catching { JSON.parse<Json>(responseBody) }
            .mapLeft { JsonParse(it) }
            .bindRight { it.parse {
                CharacterClass(
                        readStringField("_id"),
                        readStringField("index"),
                        readStringField("name"),
                        readIntField("hit_die"),
                        readArrayField("proficiency_choices") {
                            ChooseTypeFrom(
                                    readIntField("choose"),
                                    readStringField("type"),
                                    readArrayField("from") {
                                        readNameUrl()
                                    }
                            )
                        },
                        readArrayField("proficiencies") {
                            readNameUrl()
                        },
                        readArrayField("savingThrows") {
                            readNameUrl()
                        },
                        readObjectField("starting_equipment") { readUrlClass() },
                        readObjectField("class_levels") { readUrlClass() },
                        readArrayField("subclasses") {
                            readNameUrl()
                        },
                        readStringField("url"),
                        readObjectField("spellCasting") {
                            nullable {
                                readUrlClass()
                            }
                        })
                    val _id = readStringField("_id")
                    val school = readObjectField("school") {
                        val name = readStringField("name")
                        val url = readStringField("url")
                        NameUrl(name, url)
                    }
                    val desc = readArrayField("desc") {
                        readString()
                    }
                }
            }
            .mapLeft { ClientParseError(it) }
}


fun main() {

    val client = HttpClient(Js) {
    }
    val mainScope = MainScope()
    mainScope.launch {
        val resource = ApiCient(client).getResource("spells", "fire-bolt", parseThing)
        println(resource)
//        val body = response.readText()
//        val jsonBody = JSON.parse<Json>(body)
//        console.log(b)
    }
    render(document.getElementById("root")) {
        h1 {
            +"Hello, React+Kotlin/JS!"

        }
    }
//    val urlBase = "https://www.dnd5eapi.co"
//    val objectMapper = jacksonObjectMapper()
//    val resourcesBaseDirectory = readResourcesDirectory()
//    val resourceConfigBaseDir = readResourceConfigDirectory()
//
//    val spellLoader = createLoaderFor(
//            urlBase,
//            resourcesBaseDirectory,
//            "spells",
//            { text -> Either.Companion.catch { objectMapper.readValue(text, CharacterSpell::class.java) } },
//            { spell -> Either.catch { objectMapper.writeValueAsString(spell) } },
//            { Either.Right(it.index) })
//
//    val spells = runBlocking {
//        ResourceOrigin(resourceConfigBaseDir, "spells", spellLoader)
//                .loadAll()
//                .catch { println(it) }
//                .mapNotNull { when(it) {
//                    is Either.Left<Throwable> -> {
//                        println(it)
//                        null
//                    }
//                    is Either.Right<CharacterSpell> -> it.b
//                } }
//                .fold(emptyList<CharacterSpell>()) { list, item -> list + item}
//    }
//
//    val port = 8080
//
//    embeddedServer(Netty, port) {
//        routing {
//            get("/") {
//                call.respondHtml {
//                    render(MainPage("Vynne", spells))
//                }
//            }
//        }
//    }.start(wait = true)
}
//
//
//
//
//data class ResourceOrigin<T>(val baseDir: String, val resourceType: String, val resourceLoader: ResourceLoader<T>) {
//    suspend fun loadAll(): Flow<Result<T>> {
//        val result = Either.catch {
//            File("$baseDir/$resourceType.txt").useLines {
//                it.toList().asFlow()
//                        .flatMapConcat { resourceName ->
//                            flow {
//                                emit(resourceLoader.loadResource(resourceName))
//                            }
//                        }
//            }
//        }
//
//        return when(result) {
//            is Either.Left<Throwable> -> flowOf(result)
//            is Either.Right<Flow<Result<T>>> -> result.b
//        }
//    }
//}
//
//
//
//
//
//
//
//
